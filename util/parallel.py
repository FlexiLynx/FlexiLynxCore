#!/bin/python3

'''Utilities for parallellism and concurrency'''

#> Imports
import os
import time
import errno
import types
import signal
import typing
import functools
import threading
from pathlib import Path
from contextlib import AbstractContextManager
#</Imports

#> Header >/
__all__ = ('lock', 'mlock', 'FLock')

# Locking decorators
def lock(f: typing.Callable, lock: typing.ContextManager) -> typing.Callable[[typing.Callable], typing.Callable]:
    '''Creates a decorator that wraps its function in a `with` statement for `lock`'''
    def locker(f: typing.Callable):
        '''A decorator generated by `lock()`'''
        @functools.wraps(f)
        def locked(*args, **kwargs) -> typing.Any:
            with lock: return f(*args, **kwargs)
        return locked
    return locker
def mlock(f: typing.Callable) -> typing.Callable:
    '''Wraps `f` in a `with` statement for its first parameter's (probably an instance or class) `._lock` attr'''
    @functools.wraps(f)
    def mlocked(self, *args, **kwargs) -> typing.Any:
        with self._lock: return f(self, *args, **kwargs)
    return mlocked

# File-lock
class FLock(AbstractContextManager):
    '''Provides a simple lock-file implementation'''
    __slots__ = ('path', 'file', '_lock')

    def __init__(self, path: Path, lock: typing.ContextManager):
        self._lock = lock
        self.file = None
        self.path = path

    def _acquire_once(self, pid: str) -> bool:
        try:
            self.file = os.open(self.path, os.O_WRONLY | os.O_CREAT | os.O_EXCL) # open for writing only, create the file, fail if it exists
        except FileExistsError: return False
        with os.fdopen(self.file, 'w') as f: f.write(pid)
        return True

    def _unix_can_try_strong_acquire_once(self) -> bool:
        try: pid = int(self.path.read_text()) # try to get pid
        except FileNotFoundError: return True # missing lock
        except TypeError: return False # possibly corrupted lock; not safe to try to acquire
        try: os.kill(pid, 0) # try to "kill" process (signal 0 does nothing on posix but raises errors accordingly)
        except ProcessLookupError: return True # no process, try to steal lock
        except PermissionError: return False # process probably exists
    def _unix_strong_acquire_once(self, pid: str) -> bool:
        if not self._unix_can_try_strong_acquire_once(): return False
        self.path.write_text(pid)
        return self.path.read_text() == pid

    @property
    @mlock
    def held(self) -> bool: return self.file is not None

    @mlock
    def acquire(self, *, blocking: bool = True, timeout: float | None = None, poll_interval: float = 0.5,
                check_process_unix: bool = True) -> bool | None:
        '''
            Attempts to acquire the lock
                If the lock is held, instantly returns
            If `blocking` is false, then instantly returns, with a boolean success
                This boolean success will always return when `blocking` is false, and is not guaranteed otherwise
            If `timeout` is `None`, then it will stall forever until the lock is acquired
            If `check_process_unix` is true, and the running platform is Posix, then a check
                is performed using the stored PID in the lockfile. If that process
                is (**detected as**) dead, then the lockfile is forcibly cleared
                This can help in some cases where the lock is acquired, but not released when a process closes
        '''
        if self.held: return True
        pid = str(os.getpid())
        check_process_unix = check_process_unix and (os.name == 'posix')
        if not blocking: return self._acquire_once(pid) or (check_process_unix and self._unix_strong_acquire_once(pid))
        assert poll_interval > 0, 'Polling interval must be positive and more than zero'
        assert (timeout is None) or (timeout >= 0), 'Timeout can not be negative'
        hto = timeout is not None
        if hto: r = 0
        while True:
            if hto:
                if r > timeout:
                    raise TimeoutError(f'Reached timeout of ~{timeout} second(s) whilst waiting to acquire FLock')
                r += poll_interval
            if self._acquire_once(pid) or (check_process_unix and self._unix_strong_acquire_once(pid)): return # success
            time.sleep(poll_interval)
    def __enter__(self): self.acquire()

    @mlock
    def release(self):
        '''Releases the lock'''
        if not self.held: raise TypeError('Cannot release a lock that is not held')
        os.close(self.file)
        self.file = None
        self.path.unlink()
    def __exit__(self, exc_type: type[Exception] | None, exc_value: typing.Any, traceback: types.TracebackType | None): self.release()
