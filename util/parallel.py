#!/bin/python3

'''Utilities for parallellism and concurrency'''

#> Imports
import types
import typing
import functools
import threading

#</Imports

#> Header >/
__all__ = ('lock', 'mlock')

def lock(f: typing.Callable, lock: typing.ContextManager) -> typing.Callable[[typing.Callable], typing.Callable]:
    '''Creates a decorator that wraps its function in a `with` statement for `lock`'''
    def locker(f: typing.Callable):
        '''A decorator generated by `lock()`'''
        @functools.wraps(f)
        def locked(*args, **kwargs) -> typing.Any:
            with lock: return f(*args, **kwargs)
        return locked
    return locker
def mlock(f: typing.Callable) -> typing.Callable:
    '''Wraps `f` in a `with` statement for its first parameter's (probably an instance or class) `._lock` attr'''
    @functools.wraps(f)
    def mlocked(self, *args, **kwargs) -> typing.Any:
        with self._lock: return f(self, *args, **kwargs)
    return mlocked
